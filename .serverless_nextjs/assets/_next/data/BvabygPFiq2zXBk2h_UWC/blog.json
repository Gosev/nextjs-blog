{"pageProps":{"blogs":[{"id":"choix-de-framework-de-blog","title":"Le choix d'un framework de blog","img":"blog.jpg","content":"Le site de blog Medium a beaucoup de qualités. J’adore l'ergonomie de son interface d'écriture. Malheureusement le site n'est pas fait pour du contenu francophone. J’ai un blog anglophone sur Medium, mais pas de blog francophone. Je me dis que c’est l’occasion de tester des framework de génération de site statique que je ne connaissais pas, pour voir s'il y a mieux que Next.Js (que je considère meilleur que Gatsby, j'expliquerai pourquoi dans un autre article). \n\n**Pourquoi un blog ?** Pour plusieurs raisons : c'est un cas d'usage \"de la vraie vie\", qui est à la fois concrêt et tout de même relativement simple (plus simple en tout cas qu'un jeu vidéo ou qu'un site de vente en ligne). Précisons tout de meme tout de suite que je n'ai aucune idée si je vais maintenir le blog en question une fois mon choix fait, c'est un autre débat :D\n\n## Comment choisir ?\n\nDans un framework, je voudrais pouvoir :\n* avoir du **contenu dynamique** : écrire des articles en markdown, les lister automatiquement dans une page index et les injecter dans une page blog générique\n* générer des **pages statique, et les héberger sur S3**, et s'il y a besoin de logique serveur fonctionner en serverless\n* utiliser [Tailwind](https://tailwindcss.com), qui est mon framework CSS préféré en ce moment\n* inclure des videos YouTube \n* afficher du code, évidemment, il faut pouvoir faire un...\n\n```js\nconsole.log('hello world');\n```\n\n\nIdéalement j'aimerais pouvoir en profiter pour mieux comprendre un framework que je ne connais pas encore. A première vue j'ai deux choix, qui sont des équivalents de Next: *Nuxt.JS*, sur la base de Vue 3, ou *Sveltekit*, sur la base de Svelte. \nJ'ai donc suivi les guides de démarrage de ces deux framework pour (éventuellement) en choisir un. \nAvec bien sur l'option de rester sur NextJS si aucun des deux ne me convainc, évidemment !\n\nMes critères de choix prendront principalement en compte :\n* la facilité d'apprentissage et d'arriver à mes fins\n* la documentation\n* le \"DX\", c'est-à-dire l'expérience développeur\n\nDu peu que j'en ai lu, Vue a été crée par un certain Evan You qui avait travaillé sur Angular JS. Même si Angular 2+ n'a pas grand chose à voir avec Angular JS, j'ai l'impression que Svelte utilise des concepts complètement différents de ce que je connais déjà (à savoir React et Angular, côté framework côté client), donc je vais commencer avec Svelte et Sveltekit \n\n(Ah oui, petit détail, au cas où ce ne serait pas évident : j'utilise cet article - pendant que je suis en train de l'écrire en Markdown - comme contenu initial pour tester les deux systèmes de blog).\n\nUn petit point de détail : je ne connais aucun des deux framework, c'est vraiement juste une première impression. Et les premières impressions peuvent être erronées. Donc si je me trompe n'hésitez pas à me le signaler !\n\nSur ce, c'est parti pour la découverte de SvelteKit\n\n\nPremier pas avec SvelteKit \n=========================\n\nPour commencer une appli Sveltkit, il faut faire :\n\n```cli\nnpm init svelte@next mon-appli\n```\n\nQuand je lance la commande, on me propose plusieurs choix : de créer un projet vide ou une démo, d'utiliser Typescript, d'utiliser ESLint, d'utiliser Prettier. Je dis oui à tout. La démo est relativement sommaire : un compteur, une liste de todos, et un lien vers la documentation.\n\nLa doc de Svelte est intéressante mais je sais pas toujours si ce qu'elle dit est valable dans SvelteKit. Elle parle de rollup et webpack mais pas vite, qui est utilisé (si j'ai bien compris) dans SvelteKit.\n\nVoici Les premières choses qu'on nous dit dans la doc de SvelteKit : \n\nSvelteKit n'est pas encore en version stable, il pourrait y avoir des changements avant la version 1.\n\nSveltekit repose sur Svelte qui est un \"framework UI qui compile les composants pour en faire du Javascript basique\".\n\nSveltekit ne suppose pas l'existence d'un serveur contrairement à Sapper (qui était l'itération précédente du concept), il utilise des \"adaptateurs\" qui permettent de faire tourner dans différents *contextes* (sur un serveur, en statique, en serverless, ...)\n\nContraiement à Next, les routes API ne sont pas isolées dans un dossier `api/` mais regroupées par feature\" avec les fichiers qui servent à faire la présentation (les fichiers .svelte, si j'ai bien compris). D'ailleurs les fichiers correspondants ne sont pas dans un dossier `pages/` mais dans un dossier `routes/`\n\nComme Next, le chemin du fichier se traduit en URL, donc le fichier /route/contact.svelte va être rendu sur la route /contact. Par ailleurs comme sur Next il y a la possibilité de faire des routes dynamiques, de telle sorte que /route/blog/[slug].svelte permette de rendre toutes les routes de type /blog/titre-article (ou titre-article est le titre de l'article)\n\nIl y a aussi la possibilité de rendre directement des fichiers Markdown, par contre je n'arrive pas à trouver comment appliquer un style à ces fichiers, ni à en récupérer dynamiquement la liste. J'imagine qu'il faut faire une manipulation similaire à celle de next, où on utilise la librairie fs (qui lit dans le filesysteme) pour faire la liste des fichiers dans un dossier, mais la doc n'est pas très claire là dessus (pour le moment en tout cas). \n\nSvelteKit introduit d'ailleurs la notion de adders, en utilisant une commande \"npx-apply\" qui va rechercher du contenu dans un repos git (et non sur NPM) et peut-être même l'exécuter (ou exécuter un script qui modifie ou crée des fichiers de configuration, c'est pas encore très clair pour moi)\n\nParmis ces adders il y a Tailwind, \n\n\nD'autres points que j'ai glanés dans la documentation ou dans mes recherches :\n*  Apparemment SvelteKit ne marche pas bien avec Yarn.\n* Ce lien est aussi utile que les docs : https://sk-incognito.vercel.app/learn/what-is-sveltekit\n* Parmis ces adders\n\nAdders : \"npx apply svelte-add/tailwindcss  - This is a community experiment to add integrations! `npx apply` uses GitHub repositories, not NPM. You can check out the list of adders\"\n\n"},{"id":"comment-apprendre-a-coder","title":"apprendre à coder","enabled":false,"content":"No content yer"},{"id":"tutorial-next-effet-de-zoom","title":"Tutorial Next.JS +  : Effet de Zoom style medium sur l'image principale","img":"blog.jpg","ideesTitre":["Comment faire une effet dézoom type Medium",{"Tuto Next JS":"Rendre vos images plus funky avec un effet de Zoom type Gatsby"},"Rendre vos images plus attrayantes avec un effet de zoom",{"Vos images méritent le meilleur":"utiliser une LQIP pour faire un effet de mise au point"},"Donnez vie à vos images dans NextJS avec un effet de mise au point","Faites vivre vos images avec un effet de mise au point dans NextJS",{"Faites le point":"animez l'apparition de vos images avec Next JS"},"Vos images s'animent avec NextJS et du CSS",{"Tuto Effet Medium/Gastby":"Comment faire un effet de mise au point de vos images"},{"Tuto":"Optimisez vos images avec NextJS"},"Faites ressortir vos images avec Next JS et du CSS",{"Tuo Next JS":"Comment faire l'effet de mise au point sur vos images & optimiser leur chargement"},"Animez le chargement de vos images avec Next JS","Vos images n'ont plus besoin d'être ternes. Chargez les avec du style",{"Trop \"stylé\"":"utilisez CSS + Next JS pour faire un effet de mise au point sur vos images"},"Next JS + CSS => Un chargement \"trop stylé\" de vos images","Faites ressortir vos images en animant leur changement","Chargement optimisé + CSS + NextJS = trop stylé","Effet \"mise au point\" pour optimiser & animer le chargement des images","Une images animée vaut 10000 mots",{"Mettez au point vos images":"tuto Next JS pour débutants"},{"Animation et optimisation":"Comment bien charger vos images"},"Chargez mieux vos images",{"Tuto":"Animez le chargement de vos images avec NextJS"},null],"content":""},{"id":"tutorial-next-js-creation-d-un-blog","title":"Tuto Next.JS + Tailwind : créer un blog","img":"blog.jpg","content":"\n\nJe commence par installer Next.JS. \n```cli\nnpx create-next-app nextjs-blog\n```\n\nJe crée un fichier tsconfig.json pour indiquer qu'on veut etre sous Typescript (et j'installe directement Typescript)\n\n```cli\ntouch tsconfig.json\nyarn add --dev typescript @types/react\n```\n\nEnsuite c'est parti pour installer et initialiser Tailwind :\n```cli\nnpm install -D tailwindcss@latest postcss@latest autoprefixer@latest\nnpx tailwindcss init -p\n```\n\nPuis j'édite le fichier globals.css pour inclure les fichiers de style de Tailwind.\n\n```css\n/* ./styles/globals.css */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\n\nJ'aime bien changer les fichier index.js et app.js en .tsx (mais ça ne change pas grand chose)\n\nMaintenant que la base est posée, posons les bases de notre blog.\n\nLa première étape consiste à définir le type de l'article de blog, au sens Typescript. \nPour cela je crée un dossier shared/, à la racine, dans lequel je met un fichier types.d.ts qui va servir à contenir les différents types. Je vais supposer qu'on veut charger d'autres types de données que juste des articles de blog (mais je ne sais pas encore quoi à ce stade, donc j'en fais peut etre un peu trop). Néanmoins je crée un type de base pour mon contenu, que je spécialise pour l'article de blog.\n\n\n```ts\ninterface item {\n  id: string|number;\n  content: string;\n};\n\ninterface BlogPost extends item {\n  title: string;\n}\n```\n\nA présent je crée la page d'accueil du blog, en créant un fichier index.tsx, dans un dossier blog/ que je crée dans /pages. Ce fichier va servir à lister tous les articles de blog (quand il y en aura !)\n\n\n```tsx\n// pages/blog/index.tsx\n\ninterface BlogPagesProps {\n  blogs: Array<BlogPost>\n}\n\nconst BlogPages:React.FC<BlogPagesProps> = ({blog}) => {\n  return <>Blog Posts</>\n}\nexport default BlogPages;\n```\n\nA présent, allons chercher le contenu que nous allons lister. Pour ça, je commence par créer un dossier content, dans le quel je mets pour le moment un dossier blog/ (une fois de plus, ça suppose que j'ai d'autre contenu)\n\nComment est-ce que ça fonctionne ? Dans une page on peut définir une fonction getStaticProps. Cette fonction sert pour le rendu côté serveur. Elle sert à récupérer toutes les données statiques qui utiles pour rendre la page. Typiquement si on voulait faire un appel à une base de données pour lister le contenu pertinent, c'est ici qu'on le ferait. Dans notre cas, nous allons lister tous les fichiers markdown (en .md) qui sont dans le dossier content/blog, et c'est ça qui nous servira de contenu. \n\nLe nom de fichier servira d'identifiant (de champ id), mais on veut pouvoir aussi définir un titre, qui servira dans la liste sur l'accueil du blog.  \n\nUn petit détail qui est sympa avec Markdown : on peut définir des (méta)données en entête, et les lire. Ca s'appelle le *front matter*. C'est typiquement avec ça qu'on va pouvoir dire qui est l'auteur, ou quelle est l'image qu'on veut mettre en avant. \n\nUne lib existe pour les lire : gray-matter\n\nAjouter gray-matter : yarn add gray-matter\n\nCréer les fonction de récupération des données :\n\n\nOn va créer une fonction de récupération générique, qui lit un dossier et qui retourne bah.. un type de contenu.\n\nOn va commencer par lister et lire tous les fichiers md qui sont dans un dossier donné:\n\n```ts\nasync function _getAllData<T extends item>(directory: string): Promise<Array<T>> {\n  // Get file names under folder\n  const fileNames = fs.readdirSync(directory);\n  return await Promise.all (fileNames.map(async fileName => {\n    // Remove \".md\" from file name to get id\n    const id = fileName.replace(/\\.md$/, '');\n\n    // Read markdown file as string\n    const fullPath = path.join(directory, fileName);\n    const fileContents = fs.readFileSync(fullPath, 'utf8');\n\n    // Use gray-matter to parse the post metadata section\n    const matterResult = matter(fileContents);\n\n    let content = matterResult.content;\n\n    return {\n      id,\n      ...matterResult.data,\n      content,\n    } as unknown as T;\n  }));\n\n}\n```\n\nAlors je crée une fonction \"factory\", qui me fabrique la fonction en fonction du répertoire injecté :\n\n```tsx\nexport function makeGetters<T extends item> (directory: string) {\n\n  return {\n    getAllData: async () => _getAllData<T>(directory),\n  };\n}\n```\nEn suite on crée la version spécifique pour le blog :\n\nOn crée un fichier /shares/blog.ts tout simple \n\n```ts\nimport path from 'path';\nimport { makeGetters } from './content';\n\nconst directory = path.join(process.cwd(), 'content/blog');\n\nexport default makeGetters<BlogPost>(directory);\n```\n\nMaintenant on référence cette page dans l'index du blog\n\n```tsx\nimport BlogData from '../../shared/blog';\n\nexport async function getStaticProps() {\n  const blogs = await BlogData.getAllData();\n\n  return {\n    props: {\n      blogs,\n    }\n  };\n}\n\ninterface BlogPagesProps {\n  blogs: Array<BlogPost>\n}\n\nconst BlogPages:React.FC<BlogPagesProps> = ({blogs}) => {\n  return <><h1>Blog Posts</h1>\n    {blogs.map((itm) => {\n      return <><a key={itm.id}>{itm.title}</a><br/></>\n    })}\n  \n  </>\n}\n\n\n```\n\nEt on teste : wundershön \n\n\nEt du coup maintenant on va aller créer la page qui va servir à faire les articles de blog eux mêmes \n\nPour ça on crée un fichier [id].tsx dans le dossier pages/blog\n\nEn suite on fait la fonction qui récupère les données statiques en fonction de l'id\n\nAutrement dit cette fois ci au lieu de récupérer tous les fichiers on récupère le seul fichier dont l'id est dans le slug, le chemin.\n\n\n```ts\nasync function _getItemData<T extends item> (directory: string, id: string, extended?: boolean): Promise<T> {\n\n  const fullPath = path.join(directory, `${id}.md`);\n  const fileContents = fs.readFileSync(fullPath, 'utf8');\n\n  // Use gray-matter to parse the post metadata section\n  const matterResult = matter(fileContents);\n  let content = matterResult.content;\n\n  return {\n    id,\n    ...matterResult.data,\n    content,\n  } as unknown as T;\n}\n\n/* *** */\n\nexport function makeGetters<T extends item> (directory: string) {\n\n  return {\n    getItemData: async (id: string) => _getItemData<T>(directory, id),\n    getAllData: async () => _getAllData<T>(directory),\n  };\n\n}\n```\n\nEnsuite on définit dans types un paramètre\n\n```ts\ninterface StaticRouteProps {\n  params: {\n    id: string;\n  };\n}\n```\n\nEt on crée le get static props de la page :\n\n```tsx\n\ninterface PageProps {\n  data: BlogPost;\n}\n\nexport async function getStaticProps({params}:StaticRouteProps) {\n  const data = await BlogData.getItemData(params.id);\n  return {\n    props: {\n      data,\n    }\n  };\n}\n\n```\n\nIci il y a une petite particularité. Dans la mesure ou c'est un chemin dynamique, on a besoin de savoir quels sont tous les contenus qu'il faut générer. Pour ça on a une fontion \"getStaticPaths\" qui en gros liste tous les contenus\n\nOn retourne du coup dans content :\n\n```ts\nconst _getAllIds = (directory: string) => {\n  const fileNames = fs.readdirSync(directory);\n\n  return fileNames.map(fileName => {\n    return {\n      params: {\n        id: fileName.replace(/\\.md$/, '')\n      }\n    };\n  });\n};\n\n/***/\n\nexport function makeGetters<T extends item> (directory: string) {\n\n  return {\n    getAllIds: () => _getAllIds(directory),\n    getItemData: async (id: string) => _getItemData<T>(directory, id),\n    getAllData: async () => _getAllData<T>(directory),\n  };\n\n}\n```\n\nA présent dans le blog on définit la fonction getStaticPaths \n\n```ts\nexport async function getStaticPaths() {\n  const paths = BlogData.getAllIds();\n  return {\n    paths,\n    fallback: false\n  };\n}\n```\n\nA présent tout est prêt pour faire la page :\n\nOn commence par importer Head, tout en haut : \n```ts\nimport Head from 'next/head';\n```\n\nPuis on crée la fin de la page :\n\n```tsx\ninterface BlogPageProps {\n  data: BlogPost;\n}\n\nconst BlogPage: React.FC<BlogPageProps> = ({data}) => {\n\n  return <>\n    <Head> <title> {data.title} </title></Head>\n    <main>\n      <h1>{data.title}</h1>\n      <div>\n        {data.content}\n      </div>\n    </main>\n  </>;\n};\n\nexport default BlogPage;\n```\n\nMaintenant... il ne reste plus qu'à y accéder !\n\nMettons à jour la page index du blog :\n\n```tsx\nconst BlogPages:React.FC<BlogPagesProps> = ({blogs}) => {\n  return <><h1>Blog Posts</h1>\n    {blogs.map((itm) => {\n      return <><a key={itm.id} href={'/blog/'+itm.id}>{itm.title}</a><br/></>\n    })}\n  \n  </>\n}\n```\n\n\nOn teste et ... c'est très moche.\n\nOn va essayer d'améliorer ça un peu avec tailwind \n\n1/ On rajoute le typography :\nyarn add @tailwindcss/typography\n"}]},"__N_SSG":true}