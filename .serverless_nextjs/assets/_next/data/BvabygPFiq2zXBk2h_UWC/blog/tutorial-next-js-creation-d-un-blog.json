{"pageProps":{"data":{"id":"tutorial-next-js-creation-d-un-blog","title":"Tuto Next.JS + Tailwind : créer un blog","img":"blog.jpg","content":"\n\nJe commence par installer Next.JS. \n```cli\nnpx create-next-app nextjs-blog\n```\n\nJe crée un fichier tsconfig.json pour indiquer qu'on veut etre sous Typescript (et j'installe directement Typescript)\n\n```cli\ntouch tsconfig.json\nyarn add --dev typescript @types/react\n```\n\nEnsuite c'est parti pour installer et initialiser Tailwind :\n```cli\nnpm install -D tailwindcss@latest postcss@latest autoprefixer@latest\nnpx tailwindcss init -p\n```\n\nPuis j'édite le fichier globals.css pour inclure les fichiers de style de Tailwind.\n\n```css\n/* ./styles/globals.css */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\n\nJ'aime bien changer les fichier index.js et app.js en .tsx (mais ça ne change pas grand chose)\n\nMaintenant que la base est posée, posons les bases de notre blog.\n\nLa première étape consiste à définir le type de l'article de blog, au sens Typescript. \nPour cela je crée un dossier shared/, à la racine, dans lequel je met un fichier types.d.ts qui va servir à contenir les différents types. Je vais supposer qu'on veut charger d'autres types de données que juste des articles de blog (mais je ne sais pas encore quoi à ce stade, donc j'en fais peut etre un peu trop). Néanmoins je crée un type de base pour mon contenu, que je spécialise pour l'article de blog.\n\n\n```ts\ninterface item {\n  id: string|number;\n  content: string;\n};\n\ninterface BlogPost extends item {\n  title: string;\n}\n```\n\nA présent je crée la page d'accueil du blog, en créant un fichier index.tsx, dans un dossier blog/ que je crée dans /pages. Ce fichier va servir à lister tous les articles de blog (quand il y en aura !)\n\n\n```tsx\n// pages/blog/index.tsx\n\ninterface BlogPagesProps {\n  blogs: Array<BlogPost>\n}\n\nconst BlogPages:React.FC<BlogPagesProps> = ({blog}) => {\n  return <>Blog Posts</>\n}\nexport default BlogPages;\n```\n\nA présent, allons chercher le contenu que nous allons lister. Pour ça, je commence par créer un dossier content, dans le quel je mets pour le moment un dossier blog/ (une fois de plus, ça suppose que j'ai d'autre contenu)\n\nComment est-ce que ça fonctionne ? Dans une page on peut définir une fonction getStaticProps. Cette fonction sert pour le rendu côté serveur. Elle sert à récupérer toutes les données statiques qui utiles pour rendre la page. Typiquement si on voulait faire un appel à une base de données pour lister le contenu pertinent, c'est ici qu'on le ferait. Dans notre cas, nous allons lister tous les fichiers markdown (en .md) qui sont dans le dossier content/blog, et c'est ça qui nous servira de contenu. \n\nLe nom de fichier servira d'identifiant (de champ id), mais on veut pouvoir aussi définir un titre, qui servira dans la liste sur l'accueil du blog.  \n\nUn petit détail qui est sympa avec Markdown : on peut définir des (méta)données en entête, et les lire. Ca s'appelle le *front matter*. C'est typiquement avec ça qu'on va pouvoir dire qui est l'auteur, ou quelle est l'image qu'on veut mettre en avant. \n\nUne lib existe pour les lire : gray-matter\n\nAjouter gray-matter : yarn add gray-matter\n\nCréer les fonction de récupération des données :\n\n\nOn va créer une fonction de récupération générique, qui lit un dossier et qui retourne bah.. un type de contenu.\n\nOn va commencer par lister et lire tous les fichiers md qui sont dans un dossier donné:\n\n```ts\nasync function _getAllData<T extends item>(directory: string): Promise<Array<T>> {\n  // Get file names under folder\n  const fileNames = fs.readdirSync(directory);\n  return await Promise.all (fileNames.map(async fileName => {\n    // Remove \".md\" from file name to get id\n    const id = fileName.replace(/\\.md$/, '');\n\n    // Read markdown file as string\n    const fullPath = path.join(directory, fileName);\n    const fileContents = fs.readFileSync(fullPath, 'utf8');\n\n    // Use gray-matter to parse the post metadata section\n    const matterResult = matter(fileContents);\n\n    let content = matterResult.content;\n\n    return {\n      id,\n      ...matterResult.data,\n      content,\n    } as unknown as T;\n  }));\n\n}\n```\n\nAlors je crée une fonction \"factory\", qui me fabrique la fonction en fonction du répertoire injecté :\n\n```tsx\nexport function makeGetters<T extends item> (directory: string) {\n\n  return {\n    getAllData: async () => _getAllData<T>(directory),\n  };\n}\n```\nEn suite on crée la version spécifique pour le blog :\n\nOn crée un fichier /shares/blog.ts tout simple \n\n```ts\nimport path from 'path';\nimport { makeGetters } from './content';\n\nconst directory = path.join(process.cwd(), 'content/blog');\n\nexport default makeGetters<BlogPost>(directory);\n```\n\nMaintenant on référence cette page dans l'index du blog\n\n```tsx\nimport BlogData from '../../shared/blog';\n\nexport async function getStaticProps() {\n  const blogs = await BlogData.getAllData();\n\n  return {\n    props: {\n      blogs,\n    }\n  };\n}\n\ninterface BlogPagesProps {\n  blogs: Array<BlogPost>\n}\n\nconst BlogPages:React.FC<BlogPagesProps> = ({blogs}) => {\n  return <><h1>Blog Posts</h1>\n    {blogs.map((itm) => {\n      return <><a key={itm.id}>{itm.title}</a><br/></>\n    })}\n  \n  </>\n}\n\n\n```\n\nEt on teste : wundershön \n\n\nEt du coup maintenant on va aller créer la page qui va servir à faire les articles de blog eux mêmes \n\nPour ça on crée un fichier [id].tsx dans le dossier pages/blog\n\nEn suite on fait la fonction qui récupère les données statiques en fonction de l'id\n\nAutrement dit cette fois ci au lieu de récupérer tous les fichiers on récupère le seul fichier dont l'id est dans le slug, le chemin.\n\n\n```ts\nasync function _getItemData<T extends item> (directory: string, id: string, extended?: boolean): Promise<T> {\n\n  const fullPath = path.join(directory, `${id}.md`);\n  const fileContents = fs.readFileSync(fullPath, 'utf8');\n\n  // Use gray-matter to parse the post metadata section\n  const matterResult = matter(fileContents);\n  let content = matterResult.content;\n\n  return {\n    id,\n    ...matterResult.data,\n    content,\n  } as unknown as T;\n}\n\n/* *** */\n\nexport function makeGetters<T extends item> (directory: string) {\n\n  return {\n    getItemData: async (id: string) => _getItemData<T>(directory, id),\n    getAllData: async () => _getAllData<T>(directory),\n  };\n\n}\n```\n\nEnsuite on définit dans types un paramètre\n\n```ts\ninterface StaticRouteProps {\n  params: {\n    id: string;\n  };\n}\n```\n\nEt on crée le get static props de la page :\n\n```tsx\n\ninterface PageProps {\n  data: BlogPost;\n}\n\nexport async function getStaticProps({params}:StaticRouteProps) {\n  const data = await BlogData.getItemData(params.id);\n  return {\n    props: {\n      data,\n    }\n  };\n}\n\n```\n\nIci il y a une petite particularité. Dans la mesure ou c'est un chemin dynamique, on a besoin de savoir quels sont tous les contenus qu'il faut générer. Pour ça on a une fontion \"getStaticPaths\" qui en gros liste tous les contenus\n\nOn retourne du coup dans content :\n\n```ts\nconst _getAllIds = (directory: string) => {\n  const fileNames = fs.readdirSync(directory);\n\n  return fileNames.map(fileName => {\n    return {\n      params: {\n        id: fileName.replace(/\\.md$/, '')\n      }\n    };\n  });\n};\n\n/***/\n\nexport function makeGetters<T extends item> (directory: string) {\n\n  return {\n    getAllIds: () => _getAllIds(directory),\n    getItemData: async (id: string) => _getItemData<T>(directory, id),\n    getAllData: async () => _getAllData<T>(directory),\n  };\n\n}\n```\n\nA présent dans le blog on définit la fonction getStaticPaths \n\n```ts\nexport async function getStaticPaths() {\n  const paths = BlogData.getAllIds();\n  return {\n    paths,\n    fallback: false\n  };\n}\n```\n\nA présent tout est prêt pour faire la page :\n\nOn commence par importer Head, tout en haut : \n```ts\nimport Head from 'next/head';\n```\n\nPuis on crée la fin de la page :\n\n```tsx\ninterface BlogPageProps {\n  data: BlogPost;\n}\n\nconst BlogPage: React.FC<BlogPageProps> = ({data}) => {\n\n  return <>\n    <Head> <title> {data.title} </title></Head>\n    <main>\n      <h1>{data.title}</h1>\n      <div>\n        {data.content}\n      </div>\n    </main>\n  </>;\n};\n\nexport default BlogPage;\n```\n\nMaintenant... il ne reste plus qu'à y accéder !\n\nMettons à jour la page index du blog :\n\n```tsx\nconst BlogPages:React.FC<BlogPagesProps> = ({blogs}) => {\n  return <><h1>Blog Posts</h1>\n    {blogs.map((itm) => {\n      return <><a key={itm.id} href={'/blog/'+itm.id}>{itm.title}</a><br/></>\n    })}\n  \n  </>\n}\n```\n\n\nOn teste et ... c'est très moche.\n\nOn va essayer d'améliorer ça un peu avec tailwind \n\n1/ On rajoute le typography :\nyarn add @tailwindcss/typography\n"}},"__N_SSG":true}